---
import { spineModelConfig } from "../../config/pioConfig";
---

<!-- Spine Web Player CSS å°†åœ¨ script ä¸­åŠ¨æ€åŠ è½½ -->{
  spineModelConfig.enable && (
    <div
      id="spine-model-container"
      style={`
      position: fixed;
      ${spineModelConfig.position.corner.includes("right") ? "right" : "left"}: ${spineModelConfig.position.offsetX}px;
      ${spineModelConfig.position.corner.includes("top") ? "top" : "bottom"}: ${spineModelConfig.position.offsetY}px;
      width: ${spineModelConfig.size.width}px;
      height: ${spineModelConfig.size.height}px;
      pointer-events: auto;
      z-index: 1000;
    `}
    >
      <div id="spine-player-container" style="width: 100%; height: 100%;" />
      <div id="spine-error" style="display: none;" />
    </div>
  )
}

<script define:vars={{ spineModelConfig }}>
  // åŠ¨æ€åŠ è½½ Spine CSSï¼ˆå¸¦æœ¬åœ°å¤‡ç”¨ï¼‰
  function loadSpineCSS() {
    if (!spineModelConfig.enable) return;

    // æ£€æŸ¥æ˜¯å¦å·²ç»åŠ è½½
    const existingLink = document.querySelector('link[href*="spine-player"]');
    if (existingLink) return;

    // é¦–å…ˆå°è¯•åŠ è½½ CDN CSS
    const cdnLink = document.createElement("link");
    cdnLink.rel = "stylesheet";
    cdnLink.href =
      "https://unpkg.com/@esotericsoftware/spine-player@4.2.*/dist/spine-player.min.css";

    // ç›‘å¬åŠ è½½å¤±è´¥äº‹ä»¶ï¼Œè‡ªåŠ¨å›é€€åˆ°æœ¬åœ°æ–‡ä»¶
    cdnLink.onerror = function () {
      console.warn("âš ï¸ Spine CSS CDN failed, trying local fallback...");

      // ç§»é™¤å¤±è´¥çš„ CDN link
      if (cdnLink.parentNode) {
        cdnLink.parentNode.removeChild(cdnLink);
      }

      // åˆ›å»ºæœ¬åœ°å¤‡ç”¨ CSS link
      const localLink = document.createElement("link");
      localLink.rel = "stylesheet";
      localLink.href = "/pio/static/spine-player.min.css";
      localLink.onerror = function () {
        console.error("âŒ Failed to load Spine CSS");
      };

      document.head.appendChild(localLink);
    };

    document.head.appendChild(cdnLink);
  }

  // å…¨å±€å˜é‡ï¼Œè·Ÿè¸ªå½“å‰æ˜¾ç¤ºçš„æ¶ˆæ¯å®¹å™¨å’Œéšè—å®šæ—¶å™¨
  let currentMessageContainer = null;
  let hideMessageTimer = null;
  let isClickProcessing = false; // é˜²æ­¢é‡å¤ç‚¹å‡»çš„æ ‡å¿—
  let lastClickTime = 0; // è®°å½•æœ€åä¸€æ¬¡ç‚¹å‡»æ—¶é—´

  // å…¨å±€å˜é‡ï¼Œé˜²æ­¢é‡å¤åˆå§‹åŒ–
  window.spineModelInitialized = window.spineModelInitialized || false;
  window.spinePlayerInstance = window.spinePlayerInstance || null;

  // æ¶ˆæ¯æ˜¾ç¤ºå‡½æ•°
  function showMessage(message) {
    // é˜²æ­¢ç©ºæ¶ˆæ¯æˆ–é‡å¤è°ƒç”¨
    if (!message || !message.trim()) {
      return;
    }

    // ç«‹å³æ¸…é™¤ä¹‹å‰çš„æ¶ˆæ¯
    if (currentMessageContainer) {
      clearTimeout(hideMessageTimer);
      if (currentMessageContainer.parentNode) {
        currentMessageContainer.parentNode.removeChild(currentMessageContainer);
      }
      currentMessageContainer = null;
    }

    // ç¡®ä¿DOMä¸­æ²¡æœ‰æ®‹ç•™çš„æ¶ˆæ¯å®¹å™¨
    const existingMessages = document.querySelectorAll(
      ".spine-message-container"
    );
    existingMessages.forEach((msg) => {
      if (msg.parentNode) {
        msg.parentNode.removeChild(msg);
      }
    });
    // æ£€æµ‹æš—è‰²ä¸»é¢˜
    const isDarkMode =
      document.documentElement.classList.contains("dark") ||
      window.matchMedia("(prefers-color-scheme: dark)").matches;

    // åˆ›å»ºæ¶ˆæ¯å®¹å™¨
    const messageContainer = document.createElement("div");
    messageContainer.className = "spine-message-container";

    // åˆ›å»ºæ¶ˆæ¯å…ƒç´ 
    const messageEl = document.createElement("div");
    messageEl.className = "spine-message";
    messageEl.textContent = message;

    // åˆ›å»ºç®­å¤´å…ƒç´ 
    const arrowEl = document.createElement("div");
    arrowEl.className = "spine-message-arrow";

    // è®¾ç½®å®¹å™¨æ ·å¼
    Object.assign(messageContainer.style, {
      position: "fixed",
      zIndex: "1001",
      pointerEvents: "none",
      opacity: "0",
      transform: "translateY(15px) translateX(-50%) scale(0.9)",
      transition: "all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)",
    });

    // è®¾ç½®æ¶ˆæ¯æ¡†ç¾åŒ–æ ·å¼ï¼ˆæ”¯æŒæš—è‰²ä¸»é¢˜ï¼‰
    const messageStyles = {
      position: "relative",
      background: isDarkMode
        ? "linear-gradient(135deg, rgba(45, 55, 72, 0.95), rgba(26, 32, 44, 0.9))"
        : "linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(240, 248, 255, 0.9))",
      color: isDarkMode ? "#e2e8f0" : "#2c3e50",
      padding: "12px 16px",
      borderRadius: "16px",
      fontSize: "14px",
      fontWeight: "500",
      fontFamily:
        '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
      maxWidth: "240px",
      minWidth: "100px",
      wordWrap: "break-word",
      textAlign: "center",
      whiteSpace: "pre-wrap",
      boxShadow: isDarkMode
        ? "0 8px 32px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2)"
        : "0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08)",
      border: isDarkMode
        ? "1px solid rgba(255, 255, 255, 0.1)"
        : "1px solid rgba(255, 255, 255, 0.6)",
      backdropFilter: "blur(12px)",
      letterSpacing: "0.3px",
      lineHeight: "1.4",
    };
    Object.assign(messageEl.style, messageStyles);

    // è®¾ç½®ç®­å¤´æ ·å¼ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼‰
    Object.assign(arrowEl.style, {
      position: "absolute",
      top: "100%",
      left: "50%",
      transform: "translateX(-50%)", // ç®­å¤´å±…ä¸­
      width: "0",
      height: "0",
      borderLeft: "8px solid transparent",
      borderRight: "8px solid transparent",
      borderTop: isDarkMode
        ? "8px solid rgba(45, 55, 72, 0.95)"
        : "8px solid rgba(255, 255, 255, 0.95)",
      filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))",
    });

    // ç»„è£…æ¶ˆæ¯æ¡†å…ƒç´ 
    messageEl.appendChild(arrowEl);
    messageContainer.appendChild(messageEl);

    // æ·»åŠ åˆ°é¡µé¢å¹¶ä¿å­˜å¼•ç”¨
    document.body.appendChild(messageContainer);
    currentMessageContainer = messageContainer;

    // å°†æ¶ˆæ¯æ˜¾ç¤ºåœ¨ firefly å¤´é¡¶å±…ä¸­
    const container = document.getElementById("spine-model-container");
    if (container) {
      const rect = container.getBoundingClientRect();

      // æ¶ˆæ¯æ¡†å±…ä¸­æ˜¾ç¤ºåœ¨æ¨¡å‹ä¸Šæ–¹
      const containerCenterX = rect.left + rect.width / 2;

      // ä½¿ç”¨ä¼°ç®—çš„æ¶ˆæ¯æ¡†å°ºå¯¸è¿›è¡Œåˆæ­¥å®šä½
      const estimatedMessageWidth = 240; // ä½¿ç”¨maxWidthä½œä¸ºä¼°ç®—
      const estimatedMessageHeight = 60; // ä¼°ç®—é«˜åº¦
      const screenPadding = 10; // è·ç¦»å±å¹•è¾¹ç¼˜çš„æœ€å°è·ç¦»

      // è®¡ç®—æ¶ˆæ¯æ¡†çš„å®é™…ä½ç½®ï¼ˆè€ƒè™‘translateX(-50%)çš„å½±å“ï¼‰
      let messageX = containerCenterX;
      let messageY = rect.top - estimatedMessageHeight - 25; // è·ç¦»æ¨¡å‹é¡¶éƒ¨25px

      // å±å¹•è¾¹ç•Œæ£€æŸ¥ - æ°´å¹³æ–¹å‘
      const minX = screenPadding + estimatedMessageWidth / 2; // è€ƒè™‘translateX(-50%)
      const maxX =
        window.innerWidth - screenPadding - estimatedMessageWidth / 2;

      if (messageX < minX) {
        messageX = minX;
      } else if (messageX > maxX) {
        messageX = maxX;
      }

      // å±å¹•è¾¹ç•Œæ£€æŸ¥ - å‚ç›´æ–¹å‘
      const minY = screenPadding;
      const maxY = window.innerHeight - estimatedMessageHeight - screenPadding;

      if (messageY < minY) {
        // å¦‚æœä¸Šæ–¹ç©ºé—´ä¸å¤Ÿï¼Œæ˜¾ç¤ºåœ¨æ¨¡å‹ä¸‹æ–¹
        messageY = rect.bottom + 25;
        // è°ƒæ•´ç®­å¤´æ–¹å‘ï¼ˆæ˜¾ç¤ºåœ¨ä¸‹æ–¹ï¼‰
        arrowEl.style.top = "0";
        arrowEl.style.bottom = "auto";
        arrowEl.style.borderTop = "none";
        arrowEl.style.borderBottom = isDarkMode
          ? "8px solid rgba(45, 55, 72, 0.95)"
          : "8px solid rgba(255, 255, 255, 0.95)";
      } else if (messageY > maxY) {
        messageY = maxY;
      }

      // è®¾ç½®ä½ç½®
      messageContainer.style.left = messageX + "px";
      messageContainer.style.top = messageY + "px";

      // åœ¨æ¶ˆæ¯æ¡†æ¸²æŸ“åï¼Œè¿›è¡Œç²¾ç¡®çš„è¾¹ç•Œè°ƒæ•´
      setTimeout(() => {
        const actualMessageRect = messageContainer.getBoundingClientRect();
        const actualWidth = actualMessageRect.width;
        const actualHeight = actualMessageRect.height;

        // é‡æ–°è®¡ç®—æ°´å¹³ä½ç½®
        let adjustedX = containerCenterX;
        const actualMinX = screenPadding + actualWidth / 2;
        const actualMaxX = window.innerWidth - screenPadding - actualWidth / 2;

        if (adjustedX < actualMinX) {
          adjustedX = actualMinX;
        } else if (adjustedX > actualMaxX) {
          adjustedX = actualMaxX;
        }

        // é‡æ–°è®¡ç®—å‚ç›´ä½ç½®
        let adjustedY = rect.top - actualHeight - 25;
        const actualMinY = screenPadding;
        const actualMaxY = window.innerHeight - actualHeight - screenPadding;
        let isAboveModel = true; // æ ‡è®°æ¶ˆæ¯æ¡†æ˜¯å¦åœ¨æ¨¡å‹ä¸Šæ–¹

        if (adjustedY < actualMinY) {
          adjustedY = rect.bottom + 25;
          isAboveModel = false;
        } else if (adjustedY > actualMaxY) {
          adjustedY = actualMaxY;
        }

        // è®¡ç®—ç®­å¤´åº”è¯¥æŒ‡å‘çš„ä½ç½®ï¼ˆæ¨¡å‹ä¸­å¿ƒï¼‰
        const modelCenterX = rect.left + rect.width / 2;
        const messageCenterX = adjustedX; // æ¶ˆæ¯æ¡†ä¸­å¿ƒä½ç½®
        const arrowOffsetX = modelCenterX - messageCenterX; // ç®­å¤´ç›¸å¯¹äºæ¶ˆæ¯æ¡†ä¸­å¿ƒçš„åç§»

        // é™åˆ¶ç®­å¤´åç§»èŒƒå›´ï¼Œé¿å…è¶…å‡ºæ¶ˆæ¯æ¡†è¾¹ç•Œ
        const maxOffset = actualWidth / 2 - 20; // ç•™å‡º20pxè¾¹è·
        const clampedOffsetX = Math.max(
          -maxOffset,
          Math.min(maxOffset, arrowOffsetX)
        );

        // æ ¹æ®æœ€ç»ˆä½ç½®è°ƒæ•´ç®­å¤´æ–¹å‘å’Œä½ç½®
        if (isAboveModel) {
          // æ¶ˆæ¯æ¡†åœ¨æ¨¡å‹ä¸Šæ–¹ï¼Œç®­å¤´å‘ä¸‹
          Object.assign(arrowEl.style, {
            position: "absolute",
            top: "100%",
            left: "50%",
            bottom: "auto",
            transform: `translateX(calc(-50% + ${clampedOffsetX}px))`,
            width: "0",
            height: "0",
            borderLeft: "8px solid transparent",
            borderRight: "8px solid transparent",
            borderTop: isDarkMode
              ? "8px solid rgba(45, 55, 72, 0.95)"
              : "8px solid rgba(255, 255, 255, 0.95)",
            borderBottom: "none",
            filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))",
          });
        } else {
          // æ¶ˆæ¯æ¡†åœ¨æ¨¡å‹ä¸‹æ–¹ï¼Œç®­å¤´å‘ä¸Š
          Object.assign(arrowEl.style, {
            position: "absolute",
            top: "0",
            left: "50%",
            bottom: "auto",
            transform: `translateX(calc(-50% + ${clampedOffsetX}px))`,
            width: "0",
            height: "0",
            borderLeft: "8px solid transparent",
            borderRight: "8px solid transparent",
            borderTop: "none",
            borderBottom: isDarkMode
              ? "8px solid rgba(45, 55, 72, 0.95)"
              : "8px solid rgba(255, 255, 255, 0.95)",
            filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))",
          });
        }

        // åº”ç”¨è°ƒæ•´åçš„ä½ç½®
        messageContainer.style.left = adjustedX + "px";
        messageContainer.style.top = adjustedY + "px";
      }, 50); // å¢åŠ å»¶è¿Ÿç¡®ä¿æ¶ˆæ¯æ¡†å®Œå…¨æ¸²æŸ“
    }

    // æ˜¾ç¤ºåŠ¨ç”»
    setTimeout(() => {
      messageContainer.style.opacity = "1";
      messageContainer.style.transform =
        "translateY(0) translateX(-50%) scale(1)";
    }, 100); // å»¶è¿Ÿåˆ°è¾¹ç•Œè°ƒæ•´å®Œæˆå

    // è‡ªåŠ¨éšè—
    const displayTime = spineModelConfig.interactive.messageDisplayTime || 3000;
    hideMessageTimer = setTimeout(() => {
      messageContainer.style.opacity = "0";
      messageContainer.style.transform =
        "translateY(-15px) translateX(-50%) scale(0.95)";
      setTimeout(() => {
        if (messageContainer.parentNode) {
          messageContainer.parentNode.removeChild(messageContainer);
        }
        // æ¸…é™¤å¼•ç”¨
        if (currentMessageContainer === messageContainer) {
          currentMessageContainer = null;
        }
      }, 400);
    }, displayTime);
  }

  // æ›´æ–°å“åº”å¼æ˜¾ç¤º
  function updateResponsiveDisplay() {
    if (!spineModelConfig.enable) return;

    const container = document.getElementById("spine-model-container");
    if (!container) return;

    // æ£€æŸ¥ç§»åŠ¨ç«¯æ˜¾ç¤ºè®¾ç½®
    if (
      spineModelConfig.responsive.hideOnMobile &&
      window.innerWidth <= spineModelConfig.responsive.mobileBreakpoint
    ) {
      container.style.display = "none";
    } else {
      container.style.display = "block";
    }
  }

  // æ¸…ç†å‡½æ•°
  function cleanupSpineModel() {
    console.log("ğŸ§¹ Cleaning up existing Spine model...");

    // æ¸…ç†ç°æœ‰çš„æ¶ˆæ¯æ˜¾ç¤º
    if (currentMessageContainer) {
      clearTimeout(hideMessageTimer);
      if (currentMessageContainer.parentNode) {
        currentMessageContainer.parentNode.removeChild(currentMessageContainer);
      }
      currentMessageContainer = null;
    }

    // æ¸…ç†æ‰€æœ‰æ¶ˆæ¯å®¹å™¨
    const existingMessages = document.querySelectorAll(
      ".spine-message-container"
    );
    existingMessages.forEach((msg) => {
      if (msg.parentNode) {
        msg.parentNode.removeChild(msg);
      }
    });

    // æ¸…ç†ç°æœ‰çš„æ’­æ”¾å™¨å®ä¾‹
    if (window.spinePlayerInstance) {
      try {
        if (window.spinePlayerInstance.dispose) {
          window.spinePlayerInstance.dispose();
        }
      } catch (e) {
        console.warn("Error disposing spine player:", e);
      }
      window.spinePlayerInstance = null;
    }

    // æ¸…ç†å®¹å™¨å†…å®¹
    const playerContainer = document.getElementById("spine-player-container");
    if (playerContainer) {
      playerContainer.innerHTML = "";
    }

    // é‡ç½®åˆå§‹åŒ–æ ‡å¿—
    window.spineModelInitialized = false;
  }

  async function initSpineModel() {
    if (!spineModelConfig.enable) return;

    // æ£€æŸ¥æ˜¯å¦å·²ç»åˆå§‹åŒ–
    if (window.spineModelInitialized) {
      console.log("â­ï¸ Spine model already initialized, skipping...");
      return;
    }

    console.log("ğŸ¯ Initializing Spine Model...");

    // å…ˆæ¸…ç†å¯èƒ½å­˜åœ¨çš„æ—§å®ä¾‹
    cleanupSpineModel();

    // é¦–å…ˆåŠ è½½ CSS
    loadSpineCSS();

    // åŠ è½½ Spine Web Player è¿è¡Œæ—¶
    const loadSpineRuntime = () => {
      return new Promise((resolve, reject) => {
        if (typeof window.spine !== "undefined") {
          console.log("âœ… Spine runtime already loaded");
          resolve();
          return;
        }

        console.log("ğŸ“¦ Loading Spine runtime...");
        const script = document.createElement("script");
        script.src =
          "https://unpkg.com/@esotericsoftware/spine-player@4.2.*/dist/iife/spine-player.min.js";
        script.onload = () => {
          console.log("âœ… Spine runtime loaded from CDN");
          resolve();
        };
        script.onerror = (error) => {
          console.warn("âš ï¸ CDN failed, trying local fallback...");

          // å°è¯•æœ¬åœ°å›é€€
          const fallbackScript = document.createElement("script");
          fallbackScript.src = "/pio/static/spine-player.min.js";
          fallbackScript.onload = () => {
            console.log("âœ… Spine runtime loaded from local fallback");
            resolve();
          };
          fallbackScript.onerror = () => {
            reject(new Error("Failed to load Spine runtime"));
          };
          document.head.appendChild(fallbackScript);
        };
        document.head.appendChild(script);
      });
    };

    // ç­‰å¾… Spine åº“åŠ è½½
    const waitForSpine = () => {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 50;

        const check = () => {
          attempts++;
          if (typeof window.spine !== "undefined" && window.spine.SpinePlayer) {
            console.log("âœ… Spine runtime loaded");
            resolve();
          } else if (attempts >= maxAttempts) {
            reject(new Error("Spine runtime loading timeout"));
          } else {
            setTimeout(check, 100);
          }
        };
        check();
      });
    };

    try {
      // é¦–å…ˆåŠ è½½ Spine è¿è¡Œæ—¶
      await loadSpineRuntime();

      // ç„¶åç­‰å¾… Spine å¯¹è±¡å¯ç”¨
      await waitForSpine();

      // æ£€æŸ¥ç§»åŠ¨ç«¯æ˜¾ç¤ºè®¾ç½®
      if (
        spineModelConfig.responsive.hideOnMobile &&
        window.innerWidth <= spineModelConfig.responsive.mobileBreakpoint
      ) {
        const container = document.getElementById("spine-model-container");
        if (container) container.style.display = "none";
        return;
      }

      // æ ‡è®°ä¸ºå·²åˆå§‹åŒ–
      window.spineModelInitialized = true;

      // åˆ›å»º SpinePlayer
      const player = new window.spine.SpinePlayer("spine-player-container", {
        skeleton: spineModelConfig.model.path,
        atlas: spineModelConfig.model.path.replace(".json", ".atlas"),
        animation: "idle",
        backgroundColor: "#00000000", // é€æ˜èƒŒæ™¯
        showControls: false, // éšè—æ§ä»¶
        alpha: true,
        premultipliedAlpha: false,
        success: (player) => {
          console.log("ğŸ‰ Spine model loaded successfully!");

          // ä¿å­˜æ’­æ”¾å™¨å®ä¾‹å¼•ç”¨
          window.spinePlayerInstance = player;

          // åˆå§‹åŒ–å®Œæˆåè®¾ç½®é»˜è®¤å§¿æ€
          setTimeout(() => {
            if (player.skeleton) {
              try {
                player.skeleton.updateWorldTransform();
                player.skeleton.setToSetupPose();
              } catch (e) {
                console.warn("Error positioning skeleton:", e);
              }
            }
          }, 500);

          // è®¾ç½®äº¤äº’åŠŸèƒ½
          if (spineModelConfig.interactive.enabled) {
            const canvas = document.querySelector(
              "#spine-player-container canvas"
            );
            if (canvas) {
              canvas.addEventListener("click", () => {
                // é˜²æŠ–å¤„ç†ï¼šé˜²æ­¢é‡å¤ç‚¹å‡»
                const currentTime = Date.now();
                if (isClickProcessing || currentTime - lastClickTime < 500) {
                  return; // 500ms å†…é‡å¤ç‚¹å‡»å¿½ç•¥
                }

                isClickProcessing = true;
                lastClickTime = currentTime;

                // éšæœºæ’­æ”¾ç‚¹å‡»åŠ¨ç”»
                const clickAnims =
                  spineModelConfig.interactive.clickAnimations ||
                  (spineModelConfig.interactive.clickAnimation
                    ? [spineModelConfig.interactive.clickAnimation]
                    : []);

                if (clickAnims.length > 0) {
                  try {
                    const randomClickAnim =
                      clickAnims[Math.floor(Math.random() * clickAnims.length)];
                    player.setAnimation(randomClickAnim, false);

                    // åŠ¨ç”»æ’­æ”¾å®Œæˆåå›åˆ°å¾…æœºçŠ¶æ€
                    setTimeout(() => {
                      const idleAnims =
                        spineModelConfig.interactive.idleAnimations;
                      const randomIdle =
                        idleAnims[Math.floor(Math.random() * idleAnims.length)];
                      player.setAnimation(randomIdle, true);
                    }, 2000);
                  } catch (e) {
                    console.warn("Failed to play click animation:", e);
                  }
                }

                // æ˜¾ç¤ºéšæœºæ¶ˆæ¯
                const messages = spineModelConfig.interactive.clickMessages;
                if (messages && messages.length > 0) {
                  const randomMessage =
                    messages[Math.floor(Math.random() * messages.length)];
                  showMessage(randomMessage);
                }

                // 500ms åé‡ç½®é˜²æŠ–æ ‡å¿—
                setTimeout(() => {
                  isClickProcessing = false;
                }, 500);
              });

              // è®¾ç½®å¾…æœºåŠ¨ç”»å¾ªç¯
              if (spineModelConfig.interactive.idleAnimations.length > 1) {
                setInterval(() => {
                  try {
                    const idleAnims =
                      spineModelConfig.interactive.idleAnimations;
                    const randomIdle =
                      idleAnims[Math.floor(Math.random() * idleAnims.length)];
                    player.setAnimation(randomIdle, true);
                  } catch (e) {
                    console.warn("Failed to play idle animation:", e);
                  }
                }, spineModelConfig.interactive.idleInterval);
              }
            }
          }

          // æ·»åŠ æ‹–æ‹½åŠŸèƒ½
          const container = document.getElementById("spine-model-container");
          if (container) {
            let isDragging = false;
            let dragStart = { x: 0, y: 0 };
            let containerStart = { x: 0, y: 0 };

            // é¼ æ ‡äº‹ä»¶
            container.addEventListener("mousedown", (e) => {
              if (e.button !== 0) return; // åªå“åº”å·¦é”®
              isDragging = true;
              dragStart = { x: e.clientX, y: e.clientY };

              const rect = container.getBoundingClientRect();
              containerStart = { x: rect.left, y: rect.top };

              container.style.cursor = "grabbing";
              e.preventDefault();
            });

            document.addEventListener("mousemove", (e) => {
              if (!isDragging) return;

              const deltaX = e.clientX - dragStart.x;
              const deltaY = e.clientY - dragStart.y;

              const newX = containerStart.x + deltaX;
              const newY = containerStart.y + deltaY;

              // è¾¹ç•Œæ£€æŸ¥
              const maxX = window.innerWidth - container.offsetWidth;
              const maxY = window.innerHeight - container.offsetHeight;

              const clampedX = Math.max(0, Math.min(newX, maxX));
              const clampedY = Math.max(0, Math.min(newY, maxY));

              container.style.left = clampedX + "px";
              container.style.right = "auto";
              container.style.top = clampedY + "px";
              container.style.bottom = "auto";
            });

            document.addEventListener("mouseup", () => {
              if (isDragging) {
                isDragging = false;
                container.style.cursor = "grab";
              }
            });

            // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯æ”¯æŒï¼‰
            container.addEventListener("touchstart", (e) => {
              if (e.touches.length !== 1) return;
              isDragging = true;
              const touch = e.touches[0];
              dragStart = { x: touch.clientX, y: touch.clientY };

              const rect = container.getBoundingClientRect();
              containerStart = { x: rect.left, y: rect.top };

              e.preventDefault();
            });

            document.addEventListener("touchmove", (e) => {
              if (!isDragging || e.touches.length !== 1) return;

              const touch = e.touches[0];
              const deltaX = touch.clientX - dragStart.x;
              const deltaY = touch.clientY - dragStart.y;

              const newX = containerStart.x + deltaX;
              const newY = containerStart.y + deltaY;

              // è¾¹ç•Œæ£€æŸ¥
              const maxX = window.innerWidth - container.offsetWidth;
              const maxY = window.innerHeight - container.offsetHeight;

              const clampedX = Math.max(0, Math.min(newX, maxX));
              const clampedY = Math.max(0, Math.min(newY, maxY));

              container.style.left = clampedX + "px";
              container.style.right = "auto";
              container.style.top = clampedY + "px";
              container.style.bottom = "auto";

              e.preventDefault();
            });

            document.addEventListener("touchend", () => {
              isDragging = false;
            });

            // è®¾ç½®åˆå§‹å…‰æ ‡æ ·å¼
            container.style.cursor = "grab";

            // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°æ£€æŸ¥è¾¹ç•Œ
            window.addEventListener("resize", () => {
              const rect = container.getBoundingClientRect();
              const maxX = window.innerWidth - container.offsetWidth;
              const maxY = window.innerHeight - container.offsetHeight;

              if (rect.left > maxX) {
                container.style.left = maxX + "px";
                container.style.right = "auto";
              }
              if (rect.top > maxY) {
                container.style.top = maxY + "px";
                container.style.bottom = "auto";
              }
            });
          }

          console.log("âœ… Spine model setup complete!");
        },
        error: (player, reason) => {
          console.error("âŒ Spine model loading error:", reason);

          const errorDiv = document.getElementById("spine-error");
          if (errorDiv) {
            errorDiv.style.display = "block";
            errorDiv.innerHTML = `
              <div style="color: #ff4444; padding: 20px; text-align: center; font-size: 14px;">
                <div>âš ï¸ Spine æ¨¡å‹åŠ è½½å¤±è´¥</div>
                <div style="font-size: 12px; margin-top: 8px; color: #888;">${reason}</div>
              </div>
            `;
          }

          const canvas = document.getElementById("spine-canvas");
          if (canvas) canvas.style.display = "none";
        },
      });
    } catch (error) {
      console.error("Spine model initialization error:", error);

      // é‡ç½®åˆå§‹åŒ–æ ‡å¿—ï¼Œå…è®¸é‡è¯•
      window.spineModelInitialized = false;

      const errorDiv = document.getElementById("spine-error");
      if (errorDiv) {
        errorDiv.style.display = "block";
        errorDiv.innerHTML = `
          <div style="color: #ff4444; padding: 20px; text-align: center; font-size: 14px;">
            <div>âš ï¸ Spine è¿è¡Œæ—¶åŠ è½½å¤±è´¥</div>
            <div style="font-size: 12px; margin-top: 8px; color: #888;">${error instanceof Error ? error.message : "æœªçŸ¥é”™è¯¯"}</div>
          </div>
        `;
      }
    }
  }

  // ç›‘å¬é¡µé¢å¸è½½äº‹ä»¶ï¼Œæ¸…ç†èµ„æº
  window.addEventListener("beforeunload", cleanupSpineModel);

  // ç›‘å¬ Swup é¡µé¢åˆ‡æ¢äº‹ä»¶ï¼ˆå¦‚æœä½¿ç”¨äº† Swupï¼‰
  if (typeof window.swup !== "undefined" && window.swup.hooks) {
    window.swup.hooks.on("content:replace", () => {
      // åªæ›´æ–°å“åº”å¼æ˜¾ç¤ºï¼Œä¸é‡æ–°åˆ›å»ºæ¨¡å‹
      setTimeout(() => {
        updateResponsiveDisplay();
      }, 100);
    });
  }

  // ç›‘å¬ popstate äº‹ä»¶ï¼ˆæµè§ˆå™¨å‰è¿›åé€€ï¼‰
  window.addEventListener("popstate", () => {
    setTimeout(() => {
      updateResponsiveDisplay();
    }, 100);
  });

  // ç›‘å¬çª—å£å¤§å°å˜åŒ–
  window.addEventListener("resize", updateResponsiveDisplay);

  // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–ï¼ˆåªåˆå§‹åŒ–ä¸€æ¬¡ï¼‰
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initSpineModel);
  } else {
    initSpineModel();
  }
</script>
